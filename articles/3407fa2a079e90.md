---
title: "React Hooksはステートの管理と副作用のある処理を関心事ごとに整理する"
emoji: "😺"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ['React']
published: false
---

触れられていなかったReact Hooksが気になっていたので、少し勉強してみました。

後から気がついたのですが、職場で開発しているプロダクトのコードでは既にReact Hooksを使っていました。楽しそうです。

# 関数コンポーネントでステートと副作用を扱える

![useState](../images/2020-08-13/usestate.png)

Reactではコンポーネントを組み合わせてページを実装します。各コンポーネントはレンダーのサイクルをまたがるステートを持てます。コンポーネントを関数で実装することもできますが、関数コンポーネントはステートを持てませんでした。小さなコンポーネントでもステートを持つにはクラスコンポーネントにしなければならないのは面倒でした。

フックは関数コンポーネントでもステートを扱えるようにするものです。副作用のある処理をレンダーのサイクルに組み込めるようにもなります。関数コンポーネントでもクラスコンポーネントと同じことができるようになりました。

# ステートの管理と副作用のある処理をまとめる

![useEffect](../images/2020-08-13/useeffect.png)

クラスコンポーネントには副作用のある処理を実装するためのメソッドが用意されています。`componentDidMount`や`componentWillUnmount`などです。たとえば購読の開始とそのクリーンアップをこれらのメソッドに実装します。

ここで問題があります。購読の開始とクリーンアップの手続きを`componentDidMount`と`componentWillUnmount`に分けて実装する必要があり、ひとつの関心事についてのコードが分散してしまいます。また、ステートはクラスの`.state`プロパティに持つので、複数の関心事が混ざってしまいます。

フックを使うとひとつの関心事をより凝集した定義にできます。たとえば購読の開始とそのクリーンアップは`useEffect`で一度に定義できます。ステートは`useState`の戻り値で得られるので`.state`プロパティに囚われなくなります。**フックはある関心事の定義をレンダーのサイクルに結びつけるもの**と捉えられます。

クラスコンポーネントではある関心事についての実装をサイクルの中に自分で結びつける必要があります。ステートにしても副作用にしてもある関心事についての実装をクラスにねじ込むような感触があります。

# カスタムフックが美しい

![Custom hook](../images/2020-08-13/custom-hook.png)

フックは関数のトップレベルに記述するルールがあります。これは実行の順番が保たれる必要があるためのようです。たとえば`if`文などを使って条件つきでフックを呼び出してはいけません。それが守られれば一連の定義をカスタムフックとしてひとつの関数に切り出せます。

これが非常に強力です。クラスでは`.state`や`componentDidMount`に定義や呼び出しを分散せざるを得なかったものが、ひとつのカスタムフック（関数）の呼び出しにできるからです。**ステートや副作用に関するロジックを再利用しやすくなる**わけです。

ある関心事を抽出したものがカスタムフックと言えそうです。フックの仕組みがそのような切り出しを可能にしていますが、またそれ自体がフックであるとするのにある種の芸術美を感じすね。[公式](https://ja.reactjs.org/docs/hooks-custom.html)にも次のような説明があります。

> カスタムフックはReactの機能というよりは、フックの設計から自然と導かれる慣習のようなものです。

----

フックは関数コンポーネントでもステートや副作用を扱えるようにするものです。クラスに比べて、ステートや副作用を関心事に基づいて書くことができます。フックがレンダーのサイクルと関心事を結びつける役割を担うからです。また**その記述をカスタムフックに抽出できる**ことが最大のポイントだと思います。[公式のFAQ](https://ja.reactjs.org/docs/hooks-faq.html)でも「カスタムフックに抽出」と何度も言及があります。

**関心の分離**や**高凝集/疎結合**はプログラミングの重要なパラダイムだと思っています。フックをそのための仕組みだと捉えるとコードをよりエレガントなものにできる気がしてきますね。

