---
title: "Entities Pattern meets DCI Architecture ― エンティティの肥大化に立ち向かう、もうひとつの設計的視点"
emoji: "🎉"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [ドメイン駆動設計, Entities Pattern, DCI Architecture]
published: false
---

ドメイン駆動設計と言えばエンティティパターンやリポジトリパターンを思い浮かべる人も多いことでしょう。
軽量DDDやボトムアップDDDなど、戦術的設計と総称される設計パターンを重視する傾向は日本で独自に育まれてきているように感じます。
英語圏の記事や議論を眺めてみると、「BC」という単語が頻繁に登場することからも、Bonded ContextやContext Mapなどが議論の中心に据えられている印象を受けます。

書籍『エリック・エヴァンスのドメイン駆動設計』は、そのまえがきにあるとおり、設計上の意思決定を支えるパターン集として（大半が）書かれています。
そのうち、エンティティパターンやリポジトリパターンは「第2部 モデル駆動設計の構成要素」において取り上げられています。
そして、そのナビゲーションマップには「モデル駆動設計を構成する言語」と記されているように、「エンティティ」や「リポジトリ」はモデリングと設計を行うための語彙なのです。

エンティティやリポジトリといったパターンは明快で実装しやすく、多くの現場で歓迎されていることでしょう。
しかし、パターンを実装上の構造にマッピングしようとする意識が強くなり過ぎると、それらが**どのように活かされるのか**という視点がしばしば置き去りにされてしまいます。
形式としてパターンを丁寧に当てはめることで、そのアプローチは確かにひとつの道筋を与えてくれます。
ところが、実践の中では形式的なアプローチがうまく機能しない場面に出会うことも少なくありません。

本稿では、エンティティやリポジトリといったパターンを実装のレイアウトとして形式的に当てはめていくアプローチが抱えがちな実践上の課題を振り返りながら、より現実的で柔軟な考え方――**モデリングにおける「関係性」や「役割り」の視点**から、これらのパターンの活かし方を探っていきます。

:::message
ドメイン駆動設計とは、書籍『エリック・エヴァンスのドメイン駆動設計』のまえがきによると、ドメインモデリングと設計をどのようにするかを追求しようとする哲学です。

見返し（表紙と裏表紙の内側に貼り付けられた色紙）にはこの本で述べられていることの全体像を表す図が描かれています。
この図に「ユビキタス言語」と「モデル駆動設計」が軸として据えられていることから、さらにこれらが最初に述べられるパターンであることからも、この本が対話と思考の枠組みを示そうとしている姿勢が伺えます。

この記事では単に「エンティティパターン」「リポジトリパターン」と呼ぶことにします。
「軽量」であってもそれらを「DDD」と呼ぶことを差し控えるのがよいと考えるからです。
:::

## 形式的なアプローチが直面する課題

### エンティティの肥大化

エンティティパターンを実装レイアウトの基盤にしようとしたとき、早い段階で直面するのがエンティティの肥大化です。
ドメインの理解に基づいて振る舞いをエンティティに実装していく
――その設計は一見すると見事で、誠実な試みにも思えます。
しかし、振る舞いを実装し続けることでエンティティは次第に複雑さを増し、維持と管理が難しくなっていきます。

システムが大きくなるに連れ、エンティティが利用される場面も多様化していきます。
『エリック・エヴァンスのドメイン駆動設計』の「第4章 ドメインを隔離する」にある「レイヤー化アーキテクチャ」の図4.1を見てみましょう。
ここでは、振込元になる「口座」にアプリケーションサービスから`transferTo()`が呼び出されます。
その中で、振込先になる「口座」には`credit()`が、振込元の「口座」には`debit()`が呼び出される構造です。
この例では、アプリケーションサービスとの関係における振る舞いに加えて、エンティティ同士の関係における振る舞いも存在しています。
また、将来的にはさらに他のエンティティとの関係に応じた振る舞いも加わっていくでしょう。
このように、エンティティが呼び出される関連のパターンは次第に増え、複雑化していきます。

エンティティの呼び出しグラフを図にしてみると、そこに潜む問題の深刻さが次第に浮かび上がってきます。
複数のユースケースを実現する過程で、それぞれ異なる呼び出しグラフが形成されていきます。
この呼び出し関係はエンティティの振る舞い（メソッド）として実装することになります。
この図を眺めるだけでも、呼び出しが複雑に絡み合っている様子が伝わってきます。
さらに、実際に書き上がったソースコードを見るとどうでしょう。
エンティティにはいくつものユースケースに対応するためのメソッド群が実装されています。
さて、このメソッド群を前にして、もとの呼び出しグラフ――ユースケースごとの構造を想像できるでしょうか。